#include <unistd.h>
#include <stdio.h>
#include <v8.h>
#include <node.h>
#include "combine.h"

using namespace node;
using namespace v8;
using namespace std;


#define REQ_FUN_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsFunction())                   \
    return ThrowException(Exception::TypeError(                         \
                  String::New("Argument " #I " must be a function")));  \
  Local<Function> VAR = Local<Function>::Cast(args[I]);

#define REQ_STR_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsString())                   \
    return ThrowException(Exception::TypeError(                         \
                  String::New("Argument " #I " must be a string")));  \
  Local<String> VAR = Local<String>::Cast(args[I]);

#define REQ_INT_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsNumber())                   \
    return ThrowException(Exception::TypeError(                         \
                  String::New("Argument " #I " must be a number")));  \
  Local<Int32> VAR = Local<Int32>::Cast(args[I]);


class NativeImage: ObjectWrap
{
  
  //////////////////////////////////////////////////
  // Class definition, etc
  //////////////////////////////////////////////////  
  
private:
  int m_count;
public:

  static Persistent<FunctionTemplate> s_ct;
  // called once when module is required
  static void Init(Handle<Object> target)
  {
    HandleScope scope;
    // create the NativeImage Javascript function/class template
    Local<FunctionTemplate> t = FunctionTemplate::New(New);
    s_ct = Persistent<FunctionTemplate>::New(t);
    s_ct->InstanceTemplate()->SetInternalFieldCount(1);
    s_ct->SetClassName(String::NewSymbol("NativeImage"));
    // attach the "run" instance method
    NODE_SET_PROTOTYPE_METHOD(s_ct, "run", Run);
    // attach module.NativeImage
    target->Set(String::NewSymbol("NativeImage"),s_ct->GetFunction());
  }

  NativeImage() :
    m_count(0)
  {
  }

  ~NativeImage()
  {
  }
  
  // This becomes the Javascript constructor
  static Handle<Value> New(const Arguments& args)
  {
    HandleScope scope;
    NativeImage* ni = new NativeImage();
    ni->Wrap(args.This());
    return args.This();
  }
  
  //////////////////////////////////////////////////
  // run method
  //////////////////////////////////////////////////
  
  // this map is used to pass values to the new thread
  // that we will create ( to keep this method async )
  struct run_baton_t {
    NativeImage *ni;
    int sleep_for;
    v8::Persistent<v8::String> name;
    v8::Persistent<v8::Function> cb;
  };

  // STEP 1
  // this is where the method call enters from javascript
  // we extract arguments, put them on a struct,
  // and create a new thread ( libeio )
  static Handle<Value> Run(const Arguments& args)
  {
    HandleScope scope;
    
    REQ_FUN_ARG(1, cb);

    NativeImage* ni = ObjectWrap::Unwrap<NativeImage>(args.This());

    run_baton_t *baton = new run_baton_t();
    baton->ni = ni;
    baton->sleep_for = 1;
    
    // store name and callback as persistent handles
    // so they survive this context
    baton->name = v8::Persistent<v8::String>::New( args[0]->ToString() );
    baton->cb = v8::Persistent<v8::Function>::New( cb );

    // increate reference count to "this" object to prevent
    // it from being GC'd while the other thread is running
    ni->Ref();

    // start a new thread with libeio. pass struct with arguments
    eio_custom(EIO_Run, EIO_PRI_DEFAULT, EIO_AfterRun, baton);
    // Increase reference count to the event loop
    // Node.js would exit if there is nothing left
    ev_ref(EV_DEFAULT_UC);

    // this method returns undefined because work will actually
    // be done in another thread
    return Undefined();
  }

  // STEP 2
  // This method is run on a new thread
  // We recover the data passed via a struct
  // And perform our work
  static int EIO_Run(eio_req *req)
  {
    run_baton_t *baton = static_cast<run_baton_t *>(req->data);
    sleep(baton->sleep_for);
    
    v8::String::Utf8Value name_utf8(baton->name);
    char* name = *name_utf8;
    
    printf("Run %s",  name);
    printf("\n");
    fflush(stdout);
    
    /*
    string path = "/usr/src/fast-pyramid-generator/test_images/checkers/";
    string filenames[] = { path + "0_0.png", path + "1_0.png", path + "0_1.png", path + "1_1.png"};
    combine_four( filenames, "/tmp/test.jpg" );
    */

    return 0;
  }

  // STEP 3
  // The spawned thread has finished and we returned to main
  // Time to grab the callback and pass the results
  static int EIO_AfterRun(eio_req *req)
  {
    HandleScope scope;
    run_baton_t *baton = static_cast<run_baton_t *>(req->data);
    ev_unref(EV_DEFAULT_UC);
    baton->ni->Unref();

    Local<Value> argv[1];

    /*
    char* name = baton->name;
    printf("AfterRun %s",  name);
    printf("\n");
    fflush(stdout);
    */

    argv[0] = String::New( "Hello" );
    TryCatch try_catch;
    baton->cb->Call(Context::GetCurrent()->Global(), 1, argv);
    if (try_catch.HasCaught()) {
      FatalException(try_catch);
    }
    
    baton->cb.Dispose();
    baton->name.Dispose();
    
    
    
    delete baton;
    return 0;
  }
};

Persistent<FunctionTemplate> NativeImage::s_ct;
extern "C" {
  static void init (Handle<Object> target)
  {
    NativeImage::Init(target);
  }
  NODE_MODULE(nativeimage, init);
}
